Давайте интегрируем систему самообучения (self-learning) в существующий скрипт Browser_Use/test_agent3_air.py для автоматической регистрации на Airtable.

Задача: создать слой самообучения, который:
- Сохраняет историю успешных и неуспешных действий
- Адаптирует параметры (таймауты, стратегии навигации, порядок методов извлечения)
- Использует SQLite для хранения опыта между запусками
- Применяет epsilon-greedy стратегию для баланса exploitation/exploration
- Логирует все действия с метриками производительности

Критически важно:
- Не менять существующую архитектуру и внешние интерфейсы функций
- Интеграция должна быть точечной ("drop-in")
- Система должна работать сразу, без дополнительной настройки
- Все изменения должны быть обратимыми

Контекст существующего скрипта test_agent3_air.py:
- Использует Playwright для браузерной автоматизации
- Взаимодействует с Google Gemini Computer Use API для генерации действий
- Выполняет регистрацию через temp-mail.org и airtable.com
- Имеет функции: execute_computer_use_action, safe_screenshot, extract_email_from_tempmail_page, extract_verification_link_from_page
- Основная функция: main_airtable_registration_unified

Требуется полное техническое решение с готовым кодом для интеграции.


Ниже — полностью совместимая «надстройка» для самообучения, которую можно «вставить» в ваш существующий test_agent3_air.py, не переписывая архитектуру и не меняя интерфейсов (включая register_airtable_account, если вы её вызываете снаружи). Она:

- Сохраняет телеметрию шагов (время, успех/ошибку, домен, стратегию);
- Хранит и агрегирует опыт между запусками (SQLite, без внешних зависимостей);
- Автоматически подбирает параметры (стратегии navigate, таймауты, порядок извлечения ссылок/почты);
- Балансирует exploitation/exploration через epsilon-greedy;
- Встроена минимальными правками в конкретные точки (navigate, switch tabs, извлечение email и verification link, safe_screenshot, финальный результат).

Часть 1. Архитектура самообучения
- Хранилище опыта (SQLite, файл selflearn_airtable.sqlite3):
  - runs: один запуск/регистрация (phase: unified/email/registration/onboarding, статус, confirmed, время).
  - actions: пошаговая телеметрия (navigate/click/.../custom), домен, URL, параметры, время, успех/ошибка.
  - params: статистика параметров/стратегий (nav_strategy, timeouts, order методов извлечения и т.д.) с учетами n, success, tot_ms; на основе этого выбираются значения на следующих запусках.
- Политика выбора параметров:
  - Epsilon-greedy для дискретных стратегий (пример: nav_strategy ∈ {domcontentloaded, load, minimal}).
  - Ранжирование порядка методов (rank_methods) по успешности/скорости.
  - Авто-подбор численных параметров (timeouts), также через epsilon-greedy (choose_numeric).
- Точки логирования:
  - execute_computer_use_action: navigate (стратегия + ожидания), switch_to_* (ожидание после bring_to_front).
  - safe_screenshot (таймаут).
  - extract_email_from_tempmail_page (сколько ждать до появления email, порядок методов).
  - extract_verification_link_from_page (порядок методов).
  - save_registration_result (финал).
- Баланс exploitation/exploration:
  - Стратегии и таймауты выбираются через LEARN.choose_*: чаще используется лучшее наработанное, но с вероятностью epsilon берётся альтернативный вариант.
  - Epsilon можно регулировать через переменную окружения AUTOLEARN_EPS (по умолчанию 0.12).

[Далее следует полная техническая реализация с кодом для всех компонентов системы самообучения]

Итог:
- Все изменения добавляют «тонкий слой» самообучения и телеметрии в точках, где это реально влияет на стабильность: стратегия навигации, таймауты, порядок методов извлечения, ожидание после переключения вкладок и ввод.
- Архитектура и внешний интерфейс функций не изменяются.
- Система начнет накапливать знания с первого запуска и будет всё лучше выбирать параметры для temp-mail и Airtable, повышая надёжность и скорость.


Теперь, когда у нас есть рабочая система самообучения на низком уровне (выбор таймаутов, стратегий навигации, порядка методов), давайте создадим высокоуровневую систему оптимизации промптов.

Задача: использовать CoolPrompt PromptTuner для создания мета-слоя, который будет:
- Анализировать успешные и неуспешные паттерны взаимодействия из базы данных самообучения
- Генерировать оптимизированные промпты для Computer Use API на основе накопленного опыта
- Создавать адаптивные стратегии взаимодействия с различными типами веб-элементов
- Автоматически улучшать промпты для специфичных доменов (temp-mail.org, airtable.com)

Контекст интеграции:
- У нас уже есть SQLite база данных selflearn_airtable.sqlite3 с таблицами runs, actions, params
- Используется Google Gemini Computer Use API через execute_computer_use_action
- CoolPrompt доступен через: from coolprompt.assistant import PromptTuner
- Есть утилиты analyze_learning.py и analyze_strategies.py для анализа данных

Требуется:
1. Механизм извлечения паттернов из базы данных самообучения
2. Интеграция PromptTuner для генерации оптимизированных промптов на основе этих паттернов
3. Система применения сгенерированных промптов в execute_computer_use_action
4. Логирование эффективности новых промптов обратно в базу данных

Цель: создать замкнутый цикл улучшения, где низкоуровневое самообучение питает высокоуровневую оптимизацию промптов, а результаты возвращаются обратно в систему обучения.


Выступай как высококвалифицированный инженер по интеграции самообучающихся систем в существующие сценарии браузерной автоматизации на Python.  
Твоя цель — спроектировать и реализовать **точечный ("drop-in") слой самообучения** для существующего скрипта `Browser_Use/test_agent3_air.py`, который автоматизирует регистрацию на Airtable через Playwright и Google Gemini Computer Use API. При этом архитектура и внешние интерфейсы функций должны оставаться неизменными.

Следуй следующей задаче:

### Цели низкоуровневого самообучения
Создай систему, которая:
- сохраняет историю действий (успешных и неуспешных) с метриками (время, стратегия, результат);
- хранит опыт между запусками в **SQLite** (файл `selflearn_airtable.sqlite3`);
- адаптирует параметры: таймауты, стратегии навигации, порядок методов извлечения;
- применяет **epsilon-greedy** стратегию для баланса между exploitation и exploration;
- логирует действия в ключевых точках (navigate, screenshot, extract email/link, финальный результат).

Важные ограничения:
- не изменяй архитектуру и интерфейсы существующих функций (например, `execute_computer_use_action`, `safe_screenshot`, `extract_email_from_tempmail_page`, `extract_verification_link_from_page`, `main_airtable_registration_unified`);
- интеграция должна быть полностью обратимой и работать "из коробки".

### Цели высокоуровневой оптимизации промптов
После реализации базового самообучения создайте надстройку с использованием **CoolPrompt PromptTuner**:
- анализируй данные из `selflearn_airtable.sqlite3` (таблицы: runs, actions, params);
- извлекай успешные и неуспешные паттерны взаимодействия;
- через `PromptTuner` (из `coolprompt.assistant`) генерируй оптимизированные промпты для `execute_computer_use_action`;
- применяй эти промпты динамически в зависимости от домена (`temp-mail.org`, `airtable.com`);
- логируй эффективность новых промптов обратно в базу данных.

### Контекст интеграции
- Playwright отвечает за браузерную автоматизацию;
- действия генерируются Gemini Computer Use API;
- есть вспомогательные утилиты `analyze_learning.py` и `analyze_strategies.py`, которые можно использовать для анализа накопленного опыта.

### Технические требования
1. **Реализуй полный код** для слоя самообучения с SQLite-хранилищем, функциями выбора параметров и логированием.
2. **Интегрируй** CoolPrompt PromptTuner как мета-уровень: анализ → оптимизация промптов → применение → обратная связь.
3. **Продемонстрируй** как оба уровня (низкий и высокий) взаимодействуют, формируя замкнутый цикл обучения.
4. Соблюдай совместимость и обратимость: все изменения должны быть минимальными и изолированными.
5. Приведи **готовое решение с кодом**, которое можно вставить в `test_agent3_air.py` без дополнительных настроек.

Сформируй структуру ответа:
1. Архитектура решения и логика взаимодействия модулей.
2. Полный код реализации самообучающего слоя.
3. Код интеграции с CoolPrompt PromptTuner.
4. Механизм обратной связи и метрик.
5. Пояснение по внедрению и откату.

Используй чёткие комментарии и модульную структуру кода, чтобы интеграция оставалась прозрачной и управляемой.

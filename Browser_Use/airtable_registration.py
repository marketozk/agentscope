"""
üß† –ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ Airtable (—Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞)
—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–π –ø–æ—á—Ç—ã temp-mail.org ‚Äî –æ–¥–∏–Ω Agent —Å–∞–º –ø–ª–∞–Ω–∏—Ä—É–µ—Ç –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –≤—Å–µ —à–∞–≥–∏.

–ß—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å:
- –ï–î–ò–ù–´–ô ¬´Master Mission¬ª –ø—Ä–æ–º–ø—Ç: –∞–≥–µ–Ω—Ç —Å–∞–º —Ä–µ—à–∞–µ—Ç, –∫–∞–∫–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–µ–ª–∞—Ç—å –∏ –∫–æ–≥–¥–∞, –≤ –∫–∞–∫–æ–º –ø–æ—Ä—è–¥–∫–µ.
- –ß–µ—Ç–∫–∏–µ —Ü–µ–ª–∏/–∫—Ä–∏—Ç–µ—Ä–∏–∏ —É—Å–ø–µ—Ö–∞ + –ø–æ–¥—Å–∫–∞–∑–∫–∏ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º (—Å–µ–ª–µ–∫—Ç–æ—Ä—ã, –æ–∂–∏–¥–∞–Ω–∏—è, –ø—Ä–æ–≤–µ—Ä–∫–∏, —Ä–µ—Ç—Ä–∞–∏).
- –ù–∞ –≤—ã—Ö–æ–¥–µ –∞–≥–µ–Ω—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç JSON-—Ä–µ–∑—É–ª—å—Ç–∞—Ç: —Å—Ç–∞—Ç—É—Å, email, —Ñ–ª–∞–≥–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è, –∑–∞–º–µ—Ç–∫–∏.

–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∞–∑—ã (–≤–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–π –º–∏—Å—Å–∏–∏):
  A) –û—Ç–∫—Ä—ã—Ç—å —Ä–µ—Ñ–µ—Ä–∞–ª Airtable ‚Üí —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å.
  B) –ü–æ–ª—É—á–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–æ—á—Ç—É –Ω–∞ temp-mail.org (id="mail", –¥–æ–∂–¥–∞—Ç—å—Å—è, –ø–æ–∫–∞ –Ω–µ –∏—Å—á–µ–∑–Ω–µ—Ç "Loading").
  C) –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: –∑–∞–ø–æ–ª–Ω–∏—Ç—å —Ñ–æ—Ä–º—É (—Ç–æ—á–Ω—ã–π email, —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ –∏–º—è, —Å–ª–æ–∂–Ω—ã–π –ø–∞—Ä–æ–ª—å, —á–µ–∫–±–æ–∫—Å—ã); –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫–∏.
  D) –ï—Å–ª–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ ‚Üí –ø–µ—Ä–µ–π—Ç–∏ –≤ –ø–æ—á—Ç—É, –Ω–∞–π—Ç–∏ –ø–∏—Å—å–º–æ Airtable –∏ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.
  E) –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ airtable.com (dashboard/–º–µ–Ω—é) –∏ –≤–æ–∑–≤—Ä–∞—Ç JSON.
"""
import asyncio
import os
import re
from pathlib import Path
from browser_use import Agent
from browser_use.browser.profile import BrowserProfile
from dotenv import load_dotenv
from datetime import datetime
from typing import Any, Optional, Tuple

# –ò–º–ø–æ—Ä—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å rate limiting
from config import (
    get_app_config,
    get_llm,
    get_profile_path,
    wait_for_rate_limit,
    register_api_request,
    print_api_stats
)

# –ò–º–ø–æ—Ä—Ç –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
from browser_use_helpers import extract_email_from_result

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
ENV_PATH = Path(__file__).parent / ".env"
load_dotenv(dotenv_path=ENV_PATH)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã —Ç–∞–π–º–∞—É—Ç–æ–≤ –∏ –ø–æ–≤—Ç–æ—Ä–æ–≤
STEP_TIMEOUT = 240  # –¢–∞–π–º–∞—É—Ç –æ–¥–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ Agent.run(), —Å–µ–∫ (—á—É—Ç—å –±–æ–ª—å—à–µ –¥–ª—è —Å–µ—Ç–µ–≤—ã—Ö –ª–∞–≥–æ–≤)
RETRY_DELAY_SHORT = 3
RETRY_DELAY_MEDIUM = 5
RETRY_DELAY_LONG = 10
BROWSER_KEEP_ALIVE = 86400  # –î–µ—Ä–∂–∞—Ç—å –±—Ä–∞—É–∑–µ—Ä –æ—Ç–∫—Ä—ã—Ç—ã–º (24 —á–∞—Å–∞)


# ==================== –û–ë–ï–†–¢–ö–ê –î–õ–Ø LLM –° RATE LIMIT ====================

class RateLimitedLLM:
    """–û–±–µ—Ä—Ç–∫–∞ –≤–æ–∫—Ä—É–≥ LLM –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è rate limit –Ω–∞ –∫–∞–∂–¥—ã–π –≤—ã–∑–æ–≤"""
    
    def __init__(self, llm):
        self.llm = llm
        self._call_count = 0
    
    async def ainvoke(self, input: Any, config: Any = None, **kwargs) -> Any:
        """–û–±–µ—Ä—Ç–∫–∞ –≤–æ–∫—Ä—É–≥ ainvoke —Å rate limit –∫–æ–Ω—Ç—Ä–æ–ª–µ–º"""
        # –ñ–¥–µ–º –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if not await wait_for_rate_limit():
            raise Exception("–î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç API")
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
        register_api_request()
        self._call_count += 1
        
        print(f"   üî∑ LLM –≤—ã–∑–æ–≤ #{self._call_count}")
        
        # –î–µ–ª–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –≤—ã–∑–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
        if config is not None:
            return await self.llm.ainvoke(input, config, **kwargs)
        else:
            return await self.llm.ainvoke(input, **kwargs)
    
    def __getattr__(self, name):
        """–ü—Ä–æ–∫—Å–∏—Ä—É–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º—É LLM"""
        return getattr(self.llm, name)


# ==================== –£–¢–ò–õ–ò–¢–´ –ü–ê–†–°–ò–ù–ì–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í AGENT ====================

def _extract_text_from_action(action: Any) -> Optional[str]:
    """–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∏–∑–≤–ª–µ—á—å –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç –∏–∑ ActionResult.
    –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: text -> extracted_content -> output -> None
    """
    for attr in ("text", "extracted_content", "output"):
        try:
            val = getattr(action, attr, None)
            if isinstance(val, str) and val.strip():
                return val
        except Exception:
            pass
    # –ò–Ω–æ–≥–¥–∞ —Ç–µ–∫—Å—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–Ω—É—Ç—Ä–∏ dict-–ø–æ–ª—è
    try:
        if isinstance(action, dict):
            for key in ("text", "extracted_content", "output"):
                val = action.get(key)
                if isinstance(val, str) and val.strip():
                    return val
    except Exception:
        pass
    return None


def parse_agent_result(result: Any) -> dict:
    """–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ Agent —Å –±–µ–∑–æ–ø–∞—Å–Ω—ã–º —Ñ–æ–ª–±—ç–∫–æ–º.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å:
    {
      'is_done': bool|None,
      'success': bool|None,
      'error': str|None,
      'done_text': str|None,  # –∫–æ—Ä–æ—Ç–∫–∏–π –∏—Ç–æ–≥–æ–≤—ã–π —Ç–µ–∫—Å—Ç
      'raw_text': str         # –ø–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç (fallback)
    }
    """
    parsed = {
        "is_done": None,
        "success": None,
        "error": None,
        "done_text": None,
        "raw_text": str(result) if result is not None else ""
    }

    try:
        all_results = getattr(result, "all_results", None)
        # –ï—Å–ª–∏ –µ—Å—Ç—å —Å–ø–∏—Å–æ–∫ —à–∞–≥–æ–≤
        if isinstance(all_results, (list, tuple)) and all_results:
            # –ò—â–µ–º —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ
            final = None
            for item in reversed(all_results):
                try:
                    if getattr(item, "is_done", False):
                        final = item
                        break
                except Exception:
                    continue
            if final is None:
                final = all_results[-1]

            # –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–æ–ª—è
            try:
                parsed["is_done"] = getattr(final, "is_done", None)
            except Exception:
                pass
            try:
                parsed["success"] = getattr(final, "success", None)
            except Exception:
                pass
            try:
                err = getattr(final, "error", None)
                parsed["error"] = str(err) if err else None
            except Exception:
                pass
            # –æ—Å–Ω–æ–≤–Ω–æ–π –∫—Ä–∞—Ç–∫–∏–π —Ç–µ–∫—Å—Ç
            parsed["done_text"] = _extract_text_from_action(final)
            # –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç ‚Äî –º–æ–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â—ë –∏ –∏–∑ –≤—Å–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            if not parsed["done_text"]:
                parsed["done_text"] = _extract_text_from_action(result) or None

    except Exception:
        # –õ—é–±–∞—è –æ—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ ‚Äî –ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º raw_text
        pass

    return parsed


class AirtableRegistration:
    """
    –ü–æ–ª–Ω–æ—Å—Ç—å—é –∞–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ Airtable: –æ–¥–∏–Ω Agent –ø–æ–ª—É—á–∞–µ—Ç –ø–æ—á—Ç—É (temp-mail.org),
    —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è, –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç email –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.
    """

    def __init__(self, llm, referral_url: str = "https://airtable.com/invite/r/ovoAP1zR", max_retries: int = 5):
        self.llm = llm
        self.referral_url = referral_url
        self.max_retries = max_retries
        self.state = "INIT"
        self.temp_email: Optional[str] = None
        self.status: str = "unknown"
        self.confirmed: bool = False
        self.notes: str = ""
        self.agent: Optional[Agent] = None
        self.browser_profile = BrowserProfile(keep_alive=True)
        self.rate_limited_llm: Optional[RateLimitedLLM] = None

    def build_master_mission(self) -> str:
        """–ï–¥–∏–Ω—ã–π –ø—Ä–æ–º–ø—Ç –º–∏—Å—Å–∏–∏: –∞–≥–µ–Ω—Ç —Å–∞–º –ø–ª–∞–Ω–∏—Ä—É–µ—Ç –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç —à–∞–≥–∏."""
        return f"""
    ROLE: You are an autonomous web agent. Plan your own steps and act to complete the mission.
    BROWSER: You can open tabs, switch tabs, click, type, wait, run small JS, and use vision.

        MISSION GOAL:
          Create a new Airtable account using a reliable temporary email from temp-mail.org,
          then confirm the account via the confirmation email. Finish on Airtable with a verified/logged-in state.

        START HERE:
          1) Open the referral link in the FIRST tab and wait until fully loaded:
             {self.referral_url}

       EMAIL ACQUISITION (temp-mail.org):
        - Open a NEW TAB and navigate to https://temp-mail.org/en/
        - BEFORE reading email: verify page is fully loaded via JS: document.readyState === 'complete'. If not, wait 3s and check again (max 3 attempts).
        - Once readyState is 'complete', wait 20 seconds for the email field to resolve from "Loading" to a real email.
                - STRICT READ-ONLY: do NOT click, focus, type, select, hover, or press any copy buttons near the email field; do NOT use navigator.clipboard; do NOT trigger any UI events on the email widget. Only read values/attributes/text via JS.
                - Try multiple robust READ-ONLY ways to read the email (pick the first valid result that includes @):
                    1) JS: document.getElementById('mail')?.value
                    2) JS query: find any input likely holding email (READ ONLY)
                        [...document.querySelectorAll('#mail, input[type="email"], input[readonly], input[aria-label*="email" i], input[placeholder*="mail" i]')]
                           .map(e=>e.value||e.textContent||'').find(v=>v && v.includes('@'))
                    3) READ ONLY: check elements for attribute data-clipboard-text containing '@' (read attribute only, no clicks)
                        [...document.querySelectorAll('[data-clipboard-text]')].map(b=>b.getAttribute('data-clipboard-text')).find(v=>v && v.includes('@'))
                - If the value is still "Loading" or empty after the initial 20s wait ‚Üí wait 5 more seconds and retry reading; repeat up to 3 times.
        - Store the email as TEMP_EMAIL. It must include @ and not be "test@example.com".
                - Stability: avoid full page reloads too frequently; prefer the site‚Äôs own refresh control for inbox. Do not reload more than once per 10s.
                - Before any action, quickly check document.readyState via JS and wait a short moment if it's "loading".
                - Screenshot caution: during the first 5‚Äì8 seconds on temp-mail, avoid any non-essential state captures/screenshots; prefer direct JS reads to minimize overhead.
                - IMPORTANT: Once you obtain a valid TEMP_EMAIL, keep it. If the page later shows an empty box, DO NOT discard it ‚Äî reuse the stored TEMP_EMAIL unless the registration rejects it.
                - Do NOT regenerate a new email unless you detect an explicit rejection/ban/"already used" during registration.

        REGISTRATION ON AIRTABLE:
          - Switch back to the Airtable tab.
          - Fill the Email field with EXACTLY TEMP_EMAIL. First clear the field; then type character by character.
          - Fill Full Name with a realistic two-word name (e.g., Emma Williams). Do NOT use placeholders.
          - Create a strong password (letters+numbers+special): e.g., MyP@ssw0rd456.
          - Check all required checkboxes (terms/privacy).
                    - Click "Create account" (or similarly named primary submit button).
                    - AFTER CLICK ANTI-LOOP CHECK:
                        * If the button becomes disabled, shows a spinner, or the page navigates/changes content ‚Äî DO NOT click it again.
                        * Confirm state change via URL/title or appearance of new elements (e.g., welcome/onboarding/dashboard).
                        * If you clicked and nothing changes for ~5-8 seconds, re-evaluate: check for inline errors or progressed state in another area.
                        * Never click the same submit button more than 2 times without a clear state change.
          - If you see an email-related error (e.g., domain blocked or already exists), go back to temp-mail tab,
            generate a NEW email (refresh or reload), verify it's different, and retry the registration with the new email.
            Limit total email-retry cycles to {self.max_retries}.
                    - Time cap: spend no more than ~90 seconds on the registration phase. If you observe clear progress (redirect to onboarding/welcome/workspace), stop clicking and proceed to confirmation email step.

        CONFIRMATION EMAIL CHECKPOINT:
          - Only after successful account creation, go to the temp-mail tab.
                    - Prefer using the inbox refresh button on the page (not full browser reload); at most once per 10s.
                    - Wait 3-5 seconds and look for an email from Airtable (sender contains "airtable").
          - Open the email and click the main confirmation link/button.
          - Switch to the new tab (Airtable) and verify confirmation (success text, dashboard, or being logged in).

        FINAL VERIFICATION ON AIRTABLE:
          - Ensure you are on airtable.com (not signup page) and see dashboard/workspace or user menu.

        IMPORTANT EXECUTION NOTES:
          - Always verify visible text and URL before deciding.
          - Prefer stable selectors: id, name, placeholder, label text.
          - For temp-mail, use id=mail; never return the word "Loading" as the email.
                    - Before submit, verify the Email field equals TEMP_EMAIL (not test@example.com).
          - Keep a short memory of recent actions. Avoid repeating the exact same click more than 2 times unless URL/title or key DOM changed.
                    - Use short waits (2-5s) as needed; if no state change is detected ‚Äî stop repeating and choose a different action.
          - Timeout hygiene: if a tab/page seems frozen or unresponsive for ~10s, switch to another tab and back, re-check readyState, and continue; avoid infinite reload loops.
          - If something fails, explain briefly and continue to the next best step.

        OUTPUT FORMAT (MANDATORY):
          At the very end, call done(text='{{"status":"success|partial|failed","email":"<TEMP_EMAIL>","confirmed":true|false,"notes":"..."}}').
          - status=success: logged in or verified on Airtable
          - status=partial: account created but email not confirmed
          - status=failed: could not create account
          - email: the TEMP_EMAIL actually used in the form
          - confirmed: true only if verification succeeded on Airtable site
          - notes: short reason/explanation
        """

    def _parse_final_json(self, text: str) -> Tuple[Optional[dict], Optional[str]]:
        """–ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å JSON-–æ–±—ä–µ–∫—Ç –∏–∑ –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –∞–≥–µ–Ω—Ç–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ–º (data, raw)."""
        if not text:
            return None, None
        raw = text.strip()
        # –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ JSON —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏
        m = re.search(r"\{[\s\S]*\}", raw)
        if not m:
            return None, raw
        json_str = m.group(0)
        try:
            import json
            data = json.loads(json_str)
            return data, raw
        except Exception:
            return None, raw

    async def run_agent_with_rate_limit(self, timeout=STEP_TIMEOUT):
        return await asyncio.wait_for(self.agent.run(), timeout=timeout)

    async def run(self):
        print("\nüöÄ –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ Airtable (–µ–¥–∏–Ω–∞—è –º–∏—Å—Å–∏—è)")
        print("=" * 50)
        print(f"‚öôÔ∏è  –ù–∞—Å—Ç—Ä–æ–π–∫–∏: retries={self.max_retries}, timeout={STEP_TIMEOUT}—Å")
        print("=" * 50)

        try:
            # –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º LLM –¥–ª—è —Å—Ç—Ä–æ–≥–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è API –≤—ã–∑–æ–≤–æ–≤
            self.rate_limited_llm = RateLimitedLLM(self.llm)

            # –°–æ–∑–¥–∞—ë–º Agent —Å master-–º–∏—Å—Å–∏–µ–π
            self.agent = Agent(
                task=self.build_master_mission(),
                llm=self.rate_limited_llm,
                browser_profile=self.browser_profile,
                use_vision=True,
                max_failures=15,
            )

            # –û–¥–∏–Ω –∑–∞–ø—É—Å–∫ ‚Äì –∞–≥–µ–Ω—Ç –≤–Ω—É—Ç—Ä–∏ —Å–∞–º –ø–ª–∞–Ω–∏—Ä—É–µ—Ç –∏ –¥–µ–π—Å—Ç–≤—É–µ—Ç
            result = await self.run_agent_with_rate_limit()

            parsed = parse_agent_result(result)
            main_text = (parsed.get("done_text") or parsed.get("raw_text") or "").strip()
            print(f"\nüì¶ –ò—Ç–æ–≥ –æ—Ç –∞–≥–µ–Ω—Ç–∞ (—É—Å–µ—á–µ–Ω–æ): {main_text[:400]}...")

            # –ü—ã—Ç–∞–µ–º—Å—è –≤—ã—Ç–∞—â–∏—Ç—å JSON-—Ä–µ–∑—É–ª—å—Ç–∞—Ç
            data, _ = self._parse_final_json(main_text)
            if data:
                self.status = str(data.get("status", "unknown")).lower()
                self.temp_email = data.get("email") or extract_email_from_result(main_text)
                self.confirmed = bool(data.get("confirmed", False))
                self.notes = str(data.get("notes", ""))
            else:
                # –§–æ–ª–±—ç–∫: –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
                up = main_text.upper()
                self.temp_email = extract_email_from_result(main_text)
                if "SUCCESS" in up or "LOGGED_IN" in up or "VERIFIED" in up:
                    self.status = "success"
                    self.confirmed = True if "VERIFIED" in up else False
                elif "PARTIAL" in up or "ACCOUNT" in up:
                    self.status = "partial"
                else:
                    self.status = "failed"
                self.notes = "fallback parse"

            print("\n" + "=" * 50)
            print("‚úÖ –ú–∏—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
            print("=" * 50)
            print(f"üìß Email: {self.temp_email}")
            print(f"üìä –°—Ç–∞—Ç—É—Å: {self.status}, confirmed={self.confirmed}")
            if self.notes:
                print(f"üìù Notes: {self.notes[:200]}")
            total_llm_calls = getattr(self.rate_limited_llm, "_call_count", "n/a")
            print(f"üìà –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö LLM –≤—ã–∑–æ–≤–æ–≤: {total_llm_calls}")
            print("=" * 50)

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            self.save_credentials()

            # –î–µ—Ä–∂–∏–º –±—Ä–∞—É–∑–µ—Ä –æ—Ç–∫—Ä—ã—Ç—ã–º, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –≥–ª–∞–∑–∞–º–∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            print(f"\nüí§ –ë—Ä–∞—É–∑–µ—Ä –æ—Å—Ç–∞–µ—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º –Ω–∞ {BROWSER_KEEP_ALIVE // 3600} —á–∞—Å–æ–≤")
            print("   –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è...")
            await asyncio.sleep(BROWSER_KEEP_ALIVE)

        except KeyboardInterrupt:
            print("\nüëã –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
            raise
        except asyncio.TimeoutError:
            print(f"\n‚è±Ô∏è  –¢–∞–π–º–∞—É—Ç –Ω–∞ —ç—Ç–∞–ø–µ {self.state}")
            raise
        except Exception as e:
            print(f"\n‚ùå –û—à–∏–±–∫–∞ –Ω–∞ —ç—Ç–∞–ø–µ {self.state}: {e}")
            raise
        finally:
            if self.agent:
                print("\nüßπ –ó–∞–∫—Ä—ã–≤–∞–µ–º –±—Ä–∞—É–∑–µ—Ä...")
                try:
                    await self.agent.close()
                    print("‚úÖ –ë—Ä–∞—É–∑–µ—Ä –∑–∞–∫—Ä—ã—Ç")
                except Exception as e:
                    print(f"‚ö†Ô∏è  –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –±—Ä–∞—É–∑–µ—Ä–∞: {e}")
    
    def save_credentials(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ —Ñ–∞–π–ª"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"airtable_registration_{timestamp}.txt"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("=== –†–ï–ó–£–õ–¨–¢–ê–¢ –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò AIRTABLE ===\n")
            f.write(f"–î–∞—Ç–∞: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Email: {self.temp_email}\n")
            f.write(f"–°—Ç–∞—Ç—É—Å: {self.status}\n")
            f.write(f"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {self.confirmed}\n")
            if self.notes:
                f.write(f"–ó–∞–º–µ—Ç–∫–∏: {self.notes}\n")
            f.write("=" * 40 + "\n")
        
        print(f"\nüíæ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Ñ–∞–π–ª: {filename}")


async def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    try:
        config = get_app_config()
        config.print_config()
        
        llm = get_llm()
        profile_path = get_profile_path()
    except ValueError as e:
        print(f"\n‚ùå –û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
        return
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ (–±–µ–∑ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–∞ –∑–¥–µ—Å—å)
    can_run = await wait_for_rate_limit()
    if not can_run:
        print("‚õî –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç API. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å retry –º–µ—Ö–∞–Ω–∏–∑–º–æ–º (100 –ø–æ–ø—ã—Ç–æ–∫ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –≤–∞–ª–∏–¥–∞—Ü–∏–∏)
    registration = AirtableRegistration(llm, max_retries=100)
    
    try:
        await registration.run()
    except KeyboardInterrupt:
        print("\nüëã –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
    except Exception as e:
        print(f"\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        print_api_stats()


if __name__ == "__main__":
    asyncio.run(main())

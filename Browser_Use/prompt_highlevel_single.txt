Задача: высокоуровневая оптимизация промптов для управления браузерной автоматизацией через Computer Use API при сохранении существующего низкоуровневого самообучения без изменений.

Контекст (исходный замысел):
Теперь, когда у нас есть рабочая система самообучения на низком уровне (выбор таймаутов, стратегий навигации, порядка методов), давайте создадим высокоуровневую систему оптимизации промптов.

Задача: использовать CoolPrompt PromptTuner для создания мета-слоя, который будет:
- Анализировать успешные и неуспешные паттерны взаимодействия из базы данных самообучения;
- Генерировать оптимизированные промпты для Computer Use API на основе накопленного опыта;
- Создавать адаптивные стратегии взаимодействия с различными типами веб-элементов;
- Автоматически улучшать промпты для специфичных доменов (temp-mail.org, airtable.com).

Контекст интеграции:
- У нас уже есть SQLite база данных selflearn_airtable.sqlite3 с таблицами runs, actions, params;
- Используется Google Gemini Computer Use API через execute_computer_use_action;
- CoolPrompt доступен через: from coolprompt.assistant import PromptTuner;
- Есть утилиты analyze_learning.py и analyze_strategies.py для анализа данных.

Требуется:
1) Механизм извлечения паттернов из базы данных самообучения;
2) Интеграция PromptTuner для генерации оптимизированных промптов на основе этих паттернов;
3) Система применения сгенерированных промптов в execute_computer_use_action;
4) Логирование эффективности новых промптов обратно в базу данных.

Цель: создать замкнутый цикл улучшения, где низкоуровневое самообучение питает высокоуровневую оптимизацию промптов, а результаты возвращаются обратно в систему обучения.

Дополнение (важные ограничения и опоры системы):
- Базовый код уже содержит низкоуровневый механизм самообучения на основе SelfLearnStore (SQLite, файл selflearn_airtable.sqlite3) с таблицами:
  - runs — агрегаты прогонов (phase, status, confirmed, total_ms);
  - actions — телеметрия шагов (navigate/click/.../custom), домен, URL, параметры, успех/ошибка, длительность;
  - params — статистика параметров/стратегий (nav_strategy, timeouts, порядок методов) с учётом n, success, tot_ms, avg_ms.
- Политики выбора на низком уровне реализованы через epsilon-greedy:
  - choose_option для дискретных стратегий (напр., nav_strategy ∈ {domcontentloaded, load, minimal});
  - choose_numeric для численных параметров (timeouts, задержки ввода и т.п.);
  - rank_methods для обучаемого порядка методов (например, извлечение verification link/email).
- Интеграционные точки уже внедрены и остаются неизменными:
  - execute_computer_use_action: navigate (обучаемая стратегия и ожидания), switch_to_* (обучаемое ожидание после переключения вкладок);
  - safe_screenshot: обучаемый таймаут скриншотов + логирование;
  - extract_email_from_tempmail_page: активный JS-поиск + regex + селекторы с обучаемым ожиданием;
  - extract_verification_link_from_page: обучаемый порядок методов (regex/js_links/selector/click_then_*);
  - LEARN.start_run() и LEARN.finish_run() — границы прогона.
- Ключевой принцип: будет ОДИН общий стартовый высокоуровневый промпт по задаче (policy/patterns), а конкретные низкоуровневые параметры продолжит подбирать существующий самообучающийся слой. Высокоуровневая модель не должна дублировать низкоуровневую оптимизацию, а задаёт намерение, стратегию и тактические принципы.

Инструкции для генерации оптимизированного высокоуровневого промпта (что нужно от модели):
- Определить цель: надёжно и быстро проходить сценарий регистрации Airtable с использованием временной почты;
- Учитывать домены и типовые риски:
  - temp-mail.org: задержка появления email, динамика DOM, разные селекторы; избегать лишних перезагрузок;
  - airtable.com: сценарии авторизации/верификации, разные состояния формы, необходимость корректного ожидания загрузки.
- Сформулировать устойчивые высокоуровневые принципы:
  - Навигация: сначала максимально надёжная стратегия, затем при необходимости fallback — но без жёсткого перебора, т.к. низкий уровень уже обучается выбирать оптимум;
  - Извлечение данных: сначала наиболее информативные сигналы (JS-инспекция ссылок/значений), далее резервные (regex/селекторы);
  - Ожидание и тайминги: делегировать конкретные значения таймаутов и пауз низкому уровню; на высоком уровне задать принцип «ожидать ключевой сигнал страницы», а не фиксированную задержку;
  - Устранение неопределённости: повторять попытки только при сигналах неуспеха (нет email/нет селектора), избегать циклов без прогресса;
  - Телеметрия и обратная связь: формулировать шаги так, чтобы их исход (успех/время) был чётко логируем и интерпретируем низким уровнем.
- Выходом должен быть компактный и универсальный high-level prompt (policy), который можно подавать как единый стартовый контекст для Computer Use модели. Он должен:
  - Быть доменно-осознанным (temp-mail.org, airtable.com), но не привязанным к единственному лейауту;
  - Давать чёткие приоритеты действий и критерии переходов к резервным вариантам;
  - Избегать указания конкретных миллисекунд/порогов — это остаётся за low-level автотюнером;
  - Быть совместимым с многошаговыми сценариями и легко расширяться на другие домены.

Формат ожидаемого ответа:
- Название стратегии (1 строка);
- Краткое резюме (3–5 строк);
- Чёткая структура «Policy» (маркдаун-список из 10–20 пунктов с приоритетами и условиями переходов);
- Раздел «Domain notes» с компактными подсказками/рисками для temp-mail.org и airtable.com;
- Раздел «Do/Don’t» (что делать/чего избегать) — коротко, практично.

Ограничения:
- Не изменять существующие интерфейсы и точки интеграции в коде — работать поверх них;
- Не фиксировать магические числа, не вмешиваться в epsilon/ранги методов — это ответственность низкого уровня;
- Избегать чрезмерной детализации селекторов — они изменчивы; важнее принципы поиска и проверки.

Сгенерируй оптимизированный высокоуровневый промпт (на английском), соответствующий требованиям выше, чтобы его можно было использовать в качестве единого стартового задания для Computer Use модели. 

Дополнительное требование:
- Не придерживайся предыдущего скрипта; на основе текущего стека (Playwright, Google Gemini Computer Use API, SelfLearnStore/SQLite, CoolPrompt PromptTuner) спроектируй НОВЫЙ исполняемый Python-скрипт, который решает задачу end-to-end. Приведи полный исходный код (imports, функции, main), инструкции запуска для Windows CMD и перечень зависимостей. Высокоуровневый промпт задаёт стратегию, низкоуровневое самообучение остаётся без изменений (таймауты/стратегии/порядок методов выбираются через существующий SelfLearnStore).

Расширения к требованиям (критично):
- Система должна уметь САМОобучаться одновременно на двух уровнях:
  1) High-level: формировать и улучшать policy-промпт через CoolPrompt PromptTuner на основе накопленных логов/метрик;
  2) Low-level: продолжать обучение параметров в SelfLearnStore (epsilon-greedy, навигационные стратегии, таймауты, порядок методов).
- Два режима работы orchestration-скрипта:
  - learn: выполняет прогоны, собирает телеметрию, улучшает high-level policy (PromptTuner) и low-level параметры (SelfLearnStore);
  - run: использует «замороженные» артефакты (зафиксированный high-level policy и экспортированные low-level параметры) без дополнительного обучения, чтобы выполнить оптимальный найденный маршрут максимально быстро и детерминированно.
- Экспорт/заморозка артефактов:
  - high_level_policy.md — актуальная версия high-level промпта (policy), полученная через PromptTuner;
  - low_level_config.json — экспорт лучших low-level параметров из SelfLearnStore (nav_strategy по доменам, таймауты, упорядочивания методов);
  - run_plan.md — краткий «план воспроизведения» (этапы и проверки) для режима run.
- Интеграция с Computer Use: orchestration должен использовать модель Computer Use для генерации высокоуровневых шагов, руководствуясь policy-промптом; низкоуровневые параметры применяются при исполнении действий (Playwright).
- Политика токенов (важно для больших ответов): если не хватает токенов, верни максимально полезное содержимое в следующем приоритете («уровни»), чётко пометив, на каком уровне остановился ответ:
  - Tier 0: System overview (2–3 абзаца);
  - Tier 1: Архитектура (компоненты, потоки данных, границы) + диаграмма ASCII (если помещается);
  - Tier 2: Контракты интерфейсов (inputs/outputs, схемы БД/файлов, форматы логов, ключевые флаги/CLI);
  - Tier 3: Псевдокод/скелет основного orchestration-скрипта (learn/run, вызовы PromptTuner/Computer Use/Playwright, экспорт артефактов);
  - Tier 4: Минимальные кодовые заготовки (stub-реализации функций и CLI), с пометками TODO;
  - Tier 5: Полный код (если помещается) + инструкции запуска.
  В конце каждого неполного ответа добавь «CONTINUE NEEDED: Tier X+», чтобы следующая итерация могла продолжить.
- CLI-переключатели (пример): `--mode learn|run`, `--export`, `--policy in/out`, `--replay plan`, `--domain-profile <auto|tempmail|airtable>`.
- Критерии успеха: 1) успешная регистрация Airtable с верификацией; 2) время выполнения; 3) стабильность (кол-во фолбэков); 4) воспроизводимость в режиме run.